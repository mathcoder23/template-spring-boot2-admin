# Spring-Boot2-Admin模板1
> 致力于打造，生产级商用级脚手架。此项目的核心是基于SpringBoot2框架，按照微服务的方式，划分服务间的模块功能开发

此项目为轻量级的微服务框架，灵活的微服务方案，便捷的服务部署.

# 此项目的面向人群
- 快速开发产品功能
- 商业使用
- 中小型体量（微服务开发方式，单独jar包部署）
- 轻量级后台管理

# 后端项目核心组件
- Spring Boot2 (核心组件 WEB，AOP，IOC)
- Spring Security And OAuth2 (接口鉴权)
- Swagger2.10 (接口文档说明)
- Flyway (数据库结构管理)
- Mybatis Plus 3.3.0(数据库操作)
- Dynamic Datasource 3.0.0(动态数据源切换，为分库以及数据隔离做准备)

## 基础组件库
- HuTool (JAVA基础工具集)
- Commons Lang3 (JAVA基础工具集)
- Joda Time (日期处理)
- FastJson (序列化工具)

# 部署方式
- jar包部署
- Docker部署

# 项目规划

## 1.0.x 功能(规划中)
- 后端基础架构
- Web端后端基础通讯以及骨架
- 基于OAuth2鉴权通讯
- 轻量级微服务架构
- 轻量级DDD开发模式

## 框架介绍与开发逻辑
### application-service(应用服务)
- 项目拆分的微服务分别创建于此目录下。就如其名，应用服务，强调的是应用，一个整体的、完整的、可独立运行的应用服务。

- 此目录下创建的服务统一定义为“应用服务” 比如：gateway-service(网关服务，这里的网关可能包含业务本身，不是纯粹的网关)、business-service(业务服务、一个被拆分的、可以单独处理某些业务的服务，为网关服务器提供业务能力)

### application-aggregate(子服务、服务聚合)
- 应用服务是由若干的子服务聚合而成，这样做的目的是为了可能存在某些不必拆分成微服务，但有必要拆分业务处理的服务。这样不会使微服务太多
也能保证代码内部的整洁
- 应用服务组成由两部分：启动服务与子服务
- 启动服务为rest-web，这说明这是基于RESTFUL的一种接口入口，我们也可以替换为其它的入口，比如私有协议、dubbo、rabbitmq等等，只需要注意这仅是一个作为程序启动的或提供服务的入口
- application-aggregate:子服务的聚合都存放在此目录中，可以互相应用，对子服务划分可以是代码逻辑整洁而易于维护

### application-basic(应用基础)
- 应用基础为`application-service`提供基础的应用支持
- 需要慎重的理解“应用基础“，因为后面还有“框架基础”，在本项目中，应用基础强调的是对应用服务而言，需要公用的中间件配置、公共服务配置，
这些配置有个非常重要的点：这些配置是对项目而言的，意思就是说是项目的配置，而不是公共的框架配置，所以我们可以很灵活的把redis、dubbo、rabbitmq、资源存储等等放在这些应用基础中。对子服务而言需要关心的是应用方法与过程而不是配置

### framework-basic(框架基础)
- 此框架的基础核心，但也只能算一个伪核，因为核心的驱动来源于Spring Boot，此框架基础若干公共使用的基础配置，包括mybatis、常用工具类
websocket、等等的一些可以跨项目使用的组件

### 关于包名
- 由于应用服务已经实现了一些基础的业务功能，因此在真正开发时可能需要修改为项目包名
- framework-basic不必改包名，此包下的项目可能会持续更新，并由小狐维护下去。

## 部署的过程
### 编译产物
- 对于此项目而言，编译的产物最终是一个或多个jar包
### 部署的基础
1. 由上述的jar你可以选择直接使用java命令运行，但在多个服务、中间件的情况下，会使得部署与维护变得困难，因此我们选择了docker
2. 在有jar这个产物下，可以选择docker run的方式运行服务，这样的好处是将会更加简单、高效、稳定的管理jar包的生命周期，但依然无法解决复杂的微服务间通讯的问题
3. 基于上述的问题，在一个比较健壮的微服务体系下，使用docker-compose来编排微服务。如果还不能满足请尽情的享受k8s、rancher、docker swarm这些集群部署方案，但此项目中，我们目前最前沿的方式还是采用docker-compose
从发展角度讲，docker swarm后面可能会取代docker-compose，但是由于我目前的项目需要使用gpu在docker swarm下gps的使用并不是特别理想。因此还是选择docker-compose最为此项目的部署基础
### docker制品
- 我这里将docker构建的镜像为制品，因为我们写的一行行的代码被不断的加工、转换、组装。一方面这更像是一个工艺品的生产过程，另一方面可以突出拿来即用的便捷。真是如工艺品般美妙啊。
### 一个jar包到docker制品的历程
1. 编译构建产生jar包
2. docker-compose容器编排构建为docker制品

### deploy目录
- 虽说上面jar转换的历程还是很简单，但是我们需要考虑的细节还是不容小视。下面将介绍一下，本项目是如何设计一个简单、可自动化的部署方案的。
